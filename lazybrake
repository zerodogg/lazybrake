#!/usr/bin/env perl6
# lazybrake - A command-line wrapper for HandBrakeCLI that streamlines and
# automates ripping
#
# Copyright (C) Eskild Hustvedt 2016
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This POD is here to point any end-user towards the manpage.
=begin pod
For end-user documentation, see the manpage (man lazybrake, or perldoc
manpage.pod).  The documentation contained within lazybrake itself contains
details on its implementation.
=end pod

use v6;

my Real $version = 0.1;

#| Exception thrown by errOut when it can be recovered from
class recoverableError is Exception { }

#|{ Base class for all of our other classes
  Provides all of our helpers (like printv/printd) as well as class variables
  and other methods (ie. validateFile()) that all subclasses need}
class lazyBase
{
    has Int  $.verbosity = 0;
    has Int  $.min-duration = 900;
    has Int  $.max-duration;
    has Bool $.try-dvdnav = True;
    has Str  $.device;
    has Bool $.no-dvdnav   = False;
    has Bool $.two-pass    = False;
    has Bool $.looping is rw = False;
    has Bool $.movie;
    has Bool $.tv;
    has Str $.subtitle;
    has Str $.audiolang;
    has Str  $.pass-opts;
    #| Must be overridden by subclasses
    has Str @.dependencies;

    #| Output debugging text
    method printd(Str $message)
    {
        self.printv('['~self.^name~'] Debug: '~$message,99);
    }

    #| Output verbose text
    method printv(Str $message, Int $level = 1)
    {
        if $.verbosity >= $level
        {
            print $message~"\n";
        }
    }

    #| Error out
    method errOut(Str $reason, Int $retVal = 1, Bool :$canRecover = False)
    {
        $*ERR.print($reason~"\n");
        if $canRecover && $.looping
        {
            recoverableError.new.throw;
        }
        exit $retVal;
    }

    #| Checks if a command is in our PATH
    method inPath ($command)
    {
        for %*ENV<PATH>.split(':') -> $path
        {
            if ($path~'/'~$command).IO.x
            {
                return True;
            }
        }
        self.printd: $command~': not found in PATH';
        return False;
    }

    #| A generic dependency checker that just loops through @.dependencies
    method usable () returns Bool
    {
        for @.dependencies -> $command
        {
            if !self.inPath($command)
            {
                return False;
            }
        }
        return True;
    }

    #| Check if we are in tv or movie mode
    method isMode(Str $checkType) returns Bool
    {
        if $.movie && $.tv
        {
            self.errOut('Both movie and tv is True. LazyBrake-class construction error');
        }
        if $checkType eq 'tv' && $.tv
        {
            return True;
        }
        elsif $checkType eq 'movie' && $.movie
        {
            return True;
        }
        return False;
    }

    #| Parse a timestamp (HH:MM:SS or HH:MM:SS.xx)
    method parseTimestamp(Str $timestamp is copy)
    {
        try
        {
            CATCH
            {
                default
                {
                    self.printd('ERROR parsing '~$timestamp);
                    .rethrow;
                }
            }
            $timestamp ~~ s/\.\d+$//;
            my $time = $timestamp.split(':');
            my Int $len = ( +$time[2] ) + (+$time[1] *60) + ((+$time[0] *60)*60);
            my %parsed = (
                hours          => $time[0],
                minutes        => $time[1],
                seconds        => $time[2],
                totalInSeconds => $len.Int,
            );
            return %parsed;
        }
    }

    #| Instantiate a backend
    method instantiateBackend ($backendClass)
    {
        return $backendClass.new(
            :$.try-dvdnav,
            :$.min-duration,
            :$.max-duration,
            :$.device,
            :$.verbosity,
            :$.no-dvdnav,
            :$.two-pass,
            :$.subtitle,
            :$.audiolang,
            :$.pass-opts,
            :$.tv,
            :$.movie,
            :$.looping,
        );
    }

    #| Generic function to read input from a subprocess
    method getInputFrom (@cmd,$capture = 'out')
    {
        my $out;
        # Mask any localization
        my $LC_ALL = %*ENV<LC_ALL>;
        %*ENV<LC_ALL> = 'C';
        self.printd: "Running: "~@cmd.join(' ');
        if $capture eq 'out'
        {
           $out = run @cmd, :out, :err('/dev/null'.IO.open);
        }
        elsif $capture eq 'err'
        {
           $out = run @cmd, :err, :out('/dev/null'.IO.open);
        }
        elsif $capture eq 'both'
        {
           $out = run @cmd, :out, :err;
        }
        else
        {
            die: 'Unknown capture: '~$capture;
        }
        # Reset LC_ALL again
        %*ENV<LC_ALL> = $LC_ALL;
        return $out;
    }

    #| Retrieve metadata about the inserted disc
    method getDiscMetadata() returns Hash
    {
        state %cache = (
            changed => 0,
            data => Nil
        );
        # If it has changed the last three seconds, use the cached one
        if %cache<changed> > (time - 3)
        {
            self.printd: 'getDiscMetadata(): using cached disc metadata';
            return %cache<data>;
        }
        my %meta = (
            BD => False,
            DVD => False,
            MEDIA => False,
            LABEL => Nil,
            UUID => Nil,
        );
        self.printd: 'getDiscMetadata(): Asking udevadm for disc metadata';
        my $data = run 'udevadm', 'info', '-q','env','-n',$.device, :err('/dev/null'.IO.open), :out;
        for $data.out.lines -> $line
        {
            # Make it writeable
            my $content = $line;
            if $content ~~ /ID_CDROM_MEDIA_DVD\=1/
            {
                %meta<DVD> = True;
            }
            elsif $content ~~ /ID_CDROM_MEDIA_BD\=1/
            {
                %meta<BD> = True;
            }
            elsif $content ~~ /ID_CDROM_MEDIA\=1/
            {
                %meta<MEDIA> = True;
            }
            elsif $content ~~ s/^ID_FS_LABEL\=//
            {
                %meta<LABEL> = $content.chomp;
            }
            elsif $content ~~ s/^ID_FS_UUID\=//
            {
                %meta<UUID> = $content.chomp;
            }
        }
        # If we have a BD or DVD, store this in the cache
        if %meta<DVD> || %meta<BD>
        {
            %cache<changed> = time;
            %cache<data> = %meta;
        }
        return %meta;
    }
}

#| Base class for backends
class lazyBackend is lazyBase
{
    #| Returns metadata about an mp4 file using 'mp4info'
    method MP4Info (Str $file) returns Hash
    {
        my %info = ();

        my $in = run 'mp4info',$file, :out, :err;
        for $in.out.lines -> $entry is copy
        {
            next if $entry !~~ /^\d/;
            $entry ~~ s:g/\t/ /;
            my $track  = $entry;
            my $type   = $entry;
            my $length = $entry;
            $track  ~~ s/:s^(\d+)\s+.+/$0/;
            $type   ~~ s/:s^\d+\s+(\S+)\s+.+/$0/;
            $length ~~ s/:s^.*\s(\S+)\s+secs\,.*/$0/;
            %info{$type} = $length;
            self.printd('Loaded metadata on "'~$file~'": '~$type~'='~$length);
        }
        return %info;
    }

    #| Validate that a file was properly ripped by looking at the file size and video length
    method validateFile (Str :$file!, Rat :$largestRipped = 0.0, Int :$duration!) returns Bool
    {
        if ! $file.IO.e
        {
            self.printv: "$file: failed validation due to non-existant file";
            return False;
        }
        self.printd: 'Validating '~$file~' (size: '~$file.IO.s~')';

        my %fileMeta;
        if $.extension eq 'mp4'
        {
            %fileMeta = self.MP4Info($file);
        }

        if %fileMeta<video>:exists
        {
            my $maxDuration = $duration*1.005;
            my $minDuration = $duration*0.994;
            if %fileMeta<video> >= $minDuration && %fileMeta<video> <= $maxDuration
            {
                self.printd: $file~': succeeded track length validation';
                return True;
            }
            else
            {
                self.printv: "$file: failed due to video track length validation";
                self.printd: "mp4info reported the video track to be "~%fileMeta<video>~" seconds. This was compared to max[$maxDuration] and min[$minDuration]";
                return False;
            }
        }

        # This is a simple algorithm meant to verify that a file is at least of a minimum
        # file size that we expect a DVD rip to be.
        #
        # 42 minutes of video is expected to be at least 190MiB
        # 42*60 is 2520 seconds
        # 190/2520 = 0.0753 =~ 0.075MiB/second
        # Thus a file is expected to be at least length*0.075 MiB in size.
        my Int constant $sizePerSecond = 0.075;

        my Int $minSizeBytes = (($duration*$sizePerSecond)*1048576).Int;

        if $file.IO.s < $minSizeBytes
        {
            self.printd: "$file: is smaller than the minimum file size expected for this file ($minSizeBytes bytes)";
            return False;
        }
        else
        {
            self.printd: $file~': succeeded size validation';
        }

        # Drop "bytesPerSecond" checks if we have no $largestRipped
        if $largestRipped == 0.0
        {
            return True;
        }

        my Int $validationTime = ($largestRipped.Int*0.70).Int;
        my Int $bytesPerSecond = ($file.IO.s / $duration).Int;

        if $bytesPerSecond >= $largestRipped
        {
            self.printd: $file~': succeeded bytesPerSecond test';
            return True;
        }
        else
        {
            self.printv: "$file: failed due to bytesPerSecond comparison";
            self.printd: "bytesPerSecond[$bytesPerSecond] < largestRipped[$largestRipped]";
            return False;
        }

    }

    #| Run a foreground process
    method runForgeroundProcess (@command)
    {
        self.printd: "Running: "~@command.join(' ');
        try
        {
            CATCH
            {
                default
                {
                    return False;
                }
            }
            if $.verbosity >= 199
            {
                my $cmd = run @command;
            }
            else
            {
                my $cmd = run @command, :err("/dev/null".IO.open);
            }
        }
        return True;
    }

    #| Resolve the "main title" or episodes for a TV series
    method resolveTitles (%scanData)
    {
        my @titles;
        # In debug mode, output some useful info
        if $.verbosity >= 99
        {
            for @(%scanData<titleOrder>) -> $title
            {
                self.printd('Identified title '~$title~' [length: '~%scanData<titles>.{$title}.<duration>.<totalInSeconds>~']');
            }
        }
        if self.isMode('tv')
        {
            @titles = self.resolveTitlesSeries(%scanData);
        }
        elsif self.isMode('movie')
        {
            @titles = self.resolveTitleMovie(%scanData);
        }
        else
        {
            self.errOut: "resolveTitles(): unable to determine mode with isMode()";
        }
        if @titles > 15
        {
            self.errOut: "Disc looks like it has DRM-by-obscurity (found "~@titles.elems~" titles), you will need to\nspecify titles manually. Exiting.", canRecover => True;
        }
        return @titles;
    }

    #| Resolve the "main title" for a movie
    method resolveTitleMovie (%scanData)
    {
        my @titles;
        for @(%scanData<titleOrder>) -> $title
        {
            if (%scanData<titles>.{$title}.<mainTitle>)
            {
                @titles.push($title);
            }
        }
        if @titles.elems == 0
        {
            my @possibleTitles;
            my $longest;
            my $nextLongest;

            for @(%scanData<titleOrder>) -> $title
            {
                if $longest
                {
                    if %scanData<titles>.{$title}.<duration>.<totalInSeconds> >= %scanData<titles>.{$longest}.<duration>.<totalInSeconds>
                    {
                        $nextLongest = $longest;
                        $longest = $title;
                    }
                    elsif $nextLongest
                    {
                        if %scanData<titles>.{$title}.<duration>.<totalInSeconds> >= %scanData<titles>.{$nextLongest}.<duration>.<totalInSeconds>
                        {
                            $nextLongest = $longest;
                        }
                    }
                    else
                    {
                        $nextLongest = $title;
                    }
                }
                else
                {
                    $longest = $title;
                }
            }
            if $longest && $nextLongest
            {
                my $longestLen70 = %scanData<titles>.{$longest}.<duration>.<totalInSeconds> * 0.70;
                if $longestLen70 >= %scanData<titles>.{$nextLongest}.<duration>.<totalInSeconds>
                {
                    self.printd: "Fallback detection of title found title '$longest'";
                    @titles.push($longest);
                }
                else
                {
                    self.printd: "The detected longest title ($longest, $longestLen70 seconds) was not 30% longer than the next longest track. Fallback detection failed.";
                    # TODO: Loop over all titles here, if they're all
                    # of the same length, then stupid DRM is in effect
                    # and we can inform the user about it.
                    self.errOut: "Found no 'main title' on this disc, and fallback tests failed.\nTry specifying the title number manually.", canRecover => True;
                }
            }
            elsif $longest
            {
                @titles.push($longest);
            }
            else
            {
                self.errOut: "No titles were found on this disc. This is probably a lazybrake bug.", canRecover => True;
            }
        }
        return @titles;
    }

    #| Resolve the episodes for a TV series
    method resolveTitlesSeries (%scanData)
    {
        my @titles;
        if $.max-duration || $.min-duration
        {
            for @(%scanData<titleOrder>) -> $title
            {
                my $totalInSeconds = %scanData<titles>.{$title}.<duration>.<totalInSeconds>;
                if $totalInSeconds <= $.max-duration && $totalInSeconds >= $.min-duration
                {
                    @titles.push($title);
                }
                else
                {
                    my $too = 'long';
                    if $totalInSeconds < $.min-duration
                    {
                        $too = 'short';
                    }
                    self.printv: "Skipping title $title because it is too $too ("~%scanData<titles>.{$title}.<duration>.<totalInSeconds>~" seconds ["~%scanData<titles>.{$title}.<duration>.<hours>~":"~%scanData<titles>.{$title}.<duration>.<minutes>~":"~%scanData<titles>.{$title}.<duration>.<seconds>~")";
                }
            }
        }
        else
        {
            @titles = @(%scanData<titleOrder>);
        }
        return @titles;
    }
}

#| Scan-only backend: lsdvd
class backend_scan_lsdvd is lazyBackend
{
    #| This backend is NEVER directly usable
    method usable () returns Bool
    {
        return False;
    }

    #| Performs a scan with lsdvd
    method scan () returns Hash
    {
        # -Oh = enable "human" output (which is fairly parseable)
        # -a = list audio streams
        # -s = list subtitles
        my @cmd = ('lsdvd','-Oh','-a','-s',$.device);
        my $null = '/dev/null'.IO.open;
        my $in = self.getInputFrom(@cmd);
        my $currentTitle = -1;
        my $currentSubtype;
        my %data = (
            titleOrder => [],
            titles     => {}
        );
        # Used to keep track of roundtrips through the loop where no data was parsed
        # so that we can time out if it takes too long (defined as 20 seconds of inactivity).
        my $noReplyNo = 0;
        while $in.exitcode == -1 || ($currentTitle == -1 && $noReplyNo < 200)
        {
            $noReplyNo++;
            if ($noReplyNo % 10) == 0
            {
                self.printd: "No data for $noReplyNo loops. Waiting one second.";
                sleep 1;
            }
            for $in.out.lines -> $line
            {
                $noReplyNo = 0;
                if $line ~~ /:s^Title\:/
                {
                    my $title = $line;
                    my $length = $line;

                    $title ~~ s/:s^Title\:\s+0*(\d+)\D.*/$0/;
                    $length ~~ s/:s^.*Length\:\s+(\S+)\s+.*/$0/;
                    $currentTitle = $title;
                    %data<titles>.{$title} = {
                        subtitles => {},
                        mainTitle => False,
                        duration => self.parseTimestamp($length),
                    };
                    %data<titleOrder>.push($title);
                }
                elsif $currentTitle == -1
                {
                    next;
                }
                elsif $line ~~ /^\s+(Audio|Subtitle):/
                {
                    my $saveTo;
                    my $type = $line;
                    my $id   = $line;
                    my $lang = $line;

                    $type ~~ s/:s^\s+(Audio|Subtitle).*/$0/;
                    $id   ~~ s/:s^\s+(Audio|Subtitle)\:\s+0*(\d+)\,?\s+.*/$0/;
                    $lang ~~ s/:s^.*Language\:\s+(\S+)\s.*/$0/;

                    $saveTo = $type.lc;
                    if $type eq 'subtitle'
                    {
                        $saveTo = 'subtitles';
                    }
                    %data<titles>.{$currentTitle}.{$saveTo}.{$lang} = {
                        name => 'FIXME',
                        id => $id,
                    };
                }
            }
        }
        return %data;
    }
}

#| Backend: HandBrakeCLI
class backend_HDB is lazyBackend
{
    has Str $.extension = 'mp4';
    has Str @.dependencies = ('HandBrakeCLI','mp4info');

    #| Retrieve the HandBrakeCLI command-line, with basic parameters preconfigured
    method !HDBCommand (*@args) returns Array
    {
        my @cmd = 'HandBrakeCLI','-i',$.device;
        if !$.try-dvdnav
        {
            @cmd.push('--no-dvdnav');
        }
        @cmd.append(@args);
        return @cmd;
    }

    #| Parses a HandBrakeCLI --scan output
    method parseHDBScan (*@cmd) returns Hash
    {
        my $null = '/dev/null'.IO.open;
        self.printd: "Running: "~@cmd.join(' ');
        my $in = run @cmd, :err, :out($null);
        my $currentTitle = -1;
        my $currentSubtype;
        my %data = (
            titleOrder => [],
            titles     => {}
        );

        # Used to keep track of roundtrips through the loop where no data was parsed
        # so that we can time out if it takes too long (defined as 20 seconds of inactivity).
        my $noReplyNo = 0;
        while $in.exitcode == -1 || ($currentTitle == -1 && $noReplyNo < 200)
        {
            $noReplyNo++;
            if ($noReplyNo % 10) == 0
            {
                self.printd: "No data for $noReplyNo loops. Waiting one second.";
                sleep 1;
            }
            for $in.err.lines -> $line
            {
                $noReplyNo = 0;
                my $entry = $line;

                if $entry ~~ s/:s^\+ title (\d+)\:/$0/
                {
                    $entry = $entry.Int;
                    self.printd: "Found title $entry";
                    $currentSubtype = Nil;
                    $currentTitle   = $entry;
                    %data{'titleOrder'}.push($entry);
                    %data{'titles'}.{$currentTitle} = {
                        subtitles => {},
                        mainTitle => False,
                    };
                }
                elsif $currentTitle == -1
                {
                    last;
                }
                elsif $entry ~~ s/:s^\s+\+\s+duration\:\s+//
                {
                    %data{'titles'}.{$currentTitle}.{'duration'} = self.parseTimestamp($entry);
                }
                elsif $entry ~~ /:s^  \+ Main Feature/ && $currentTitle.defined
                {
                    %data<titles>.{$currentTitle}.<mainTitle> = True;
                }
                elsif $entry ~~ s/:s^  \+ (.+)\:\s*$/$0/
                {
                    $currentSubtype = $entry;
                }
                elsif $entry ~~ s/:s^    \+\s*// && $currentSubtype
                {
                    if $currentSubtype eq 'subtitle tracks' || $currentSubtype eq 'audio tracks'
                    {
                        my $saveTo;
                        if $currentSubtype eq 'subtitle tracks'
                        {
                            $saveTo = 'subtitles';
                        }
                        elsif $currentSubtype eq 'audio tracks'
                        {
                            $saveTo = 'audio';
                        }

                        my $trackID   = $entry;
                        my $trackName = $entry;
                        my $trackISO  = $entry;

                        $trackID   ~~ s/^\s*(\d+)\,.*/$0/;
                        $trackName ~~ s/^\s*\d+\,\s+(\S+)\s+.*/$0/;
                        $trackISO  ~~ s/^.+iso\d+\-\d+\:\s+(\S+)\).*/$0/;
                        if $trackISO ~~ /\s+/
                        {
                            self.printd: 'Parsed out a strange trackISO for '~$currentSubtype~': "'~$trackISO~'". Did not expect spaces in it. Skipping this entry.';
                            self.printd: 'Parsed out the following id/name variables: trackID='~$trackID~' || trackName='~$trackName;
                        }
                        elsif ! %data<titles>.{$currentTitle}.{$saveTo}.{$trackISO}
                        {
                            %data<titles>.{$currentTitle}.{$saveTo}.{$trackISO} = {
                                name => $trackName,
                                id   => $trackID
                            };
                        }
                    }
                }
            }
        }
        return %data;
    }

    #| Performs a scan with HandBrakeCLI --scan and returns its data in a hash
    method scan () returns Hash
    {
        my %result;
        my $success = False;
        my @cmd = self!HDBCommand('--min-duration',$.min-duration,'--scan','-t',0,'--previews=1:0');
        try
        {
            %result = self.parseHDBScan: @cmd;
            $success = True;
        }

        if !$.try-dvdnav
        {
            if !$success
            {
                self.errOut: "Scanning failed, try to enable dvdnav";
            }
            return %result;
        }

        if !$success
        {
            say "error - use of dvdnav failed, trying without dvdnav";
        }
        elsif %result<titleOrder>.elems <= 1
        {
            say "questionable result - trying without dvdnav";
            self.printd: "Only got "~%result<titleOrder>.elems~" titles, not trusting the result, will retry without libdvdnav";
            $success = False;
        }

        if !$success
        {
            print "Scanning without dvdnav...";
            @cmd.push('--no-dvdnav');
            %result = self.parseHDBScan: @cmd;
        }
        return %result;
    }

    #| Get an array of audio/subtitle params for HandBrakeCLI
    method buildAudioSubParams(:%metadata!, :$title!)
    {
        my @params;
        my $type;

        for <subtitles audio> -> $type
        {
            my @final;
            my $entries;
            my $dataType;
            if ($type eq 'subtitles')
            {
                $entries = $.subtitle;
                $dataType = 'subtitles';
            }
            elsif ($type eq 'audio')
            {
                $entries = $.audiolang;
                $dataType = 'audio';
            }
            else
            {
                die;
            }

            if (!$entries)
            {
                next;
            }

            for $entries.split(',') -> $entries
            {
                my $origTitle = $entries;
                if $entries && %metadata{$dataType} && !%metadata.{$dataType}.{$entries}
                {
                    for %metadata{$dataType}.keys -> $subkey
                    {
                        if %metadata{$dataType}.{$subkey} && (%metadata{$dataType}.{$subkey}.<name>:exists) && %metadata{$dataType}.{$subkey}.<name> eq $entries
                        {
                            self.printv: "Remapped $entries to $subkey";
                            last;
                        }
                    }
                }
                if $entries && %metadata{$dataType}.{$entries}
                {
                    self.printd: 'Using '~%metadata{$dataType}.{$entries}.<id>~' as '~$dataType~' ID for '~$origTitle;
                    @final.push(%metadata{$dataType}.{$entries}.<id>);
                }
                else
                {
                    if ($dataType eq 'subtitles')
                    {
                        say "Title $title has no subtitle \"$origTitle\": skipping this subtitle";
                    }
                    elsif ($dataType eq 'audio')
                    {
                        say "Title $title has no audio language \"$origTitle\": skipping this language";
                    }
                }
            }
            if @final.elems > 0
            {
                if ($dataType eq 'subtitles')
                {
                    @params.push('--subtitle',@final.join(','));
                }
                elsif ($dataType eq 'audio')
                {
                    @params.push('--audio',@final.join(','));
                }
            }
        }

        return @params;
    }

    #| Rips a single title using the settings provided
    method ripSingleTitle(Int :$title!, :$filename!, :%metadata!, :$preset = 'Normal', Bool :$no-dvdnav is copy = False) returns Hash
    {
        my @command = self!HDBCommand('-v0', '-t', $title, '-o', $filename,'--preset',$preset);
        @command.append: self.buildAudioSubParams(:%metadata,:$title);
        if $.two-pass
        {
            @command.append: '--two-pass';
        }
        if $.pass-opts
        {
            @command.append: $.pass-opts;
        }
        if $no-dvdnav && $.try-dvdnav
        {
            @command.push('--no-dvdnav');
        }
        if self.runForgeroundProcess(@command) == False
        {
            return {
                success => False
            };
        }
        if !$no-dvdnav && (!$filename.IO.e || !self.validateFile(file => $filename, duration => %metadata<duration>.<totalInSeconds>))
        {
            if !$.try-dvdnav
            {
                say "(error, trying to re-rip)";
            }
            else
            {
                say "(error, trying to re-rip without using dvdnav)";
                @command.push('--no-dvdnav');
            }
            sleep(2);
            my $tmpStorageName = $filename~'-lazybrake.validation.backup~';
            if $filename.IO.e
            {
                $filename.IO.rename($tmpStorageName);
            }
            else
            {
                $tmpStorageName = Nil;
            }
            self.printd: "Running: "~@command.join(' ');
            try
            {
                CATCH
                {
                    return {
                        success => False,
                    };
                }
                if $.verbosity >= 199
                {
                    my $cmd = run @command;
                }
                else
                {
                    my $cmd = run @command, :err("/dev/null".IO.open);
                }
            }
            return {
                success => True,
                tmpName => $tmpStorageName
            }
        }
        return {
            success => True
        };
    }
}

#|{ Backend: makemkvcon
  Note: This is a hybrid backend. makemkvcon is used for ripping, but HandBrakeCLI
  still handles scanning
}
class backend_mmkv is lazyBackend
{
    has Str $.extension = 'mkv';
    has Str @.dependencies = ('makemkvcon');

    #| Verify that unsupported features are not enabled. Override this method
    #| in your subclass if you implement the feature yourself.
    method unsupportedFeatureCheck ()
    {
        if $.subtitle || $.audiolang
        {
            self.errOut: 'The makemkv backend does not support --subtitle or --audiolang';
        }
        if $.two-pass
        {
            self.printv: 'Note: The makemkv backend does not support (or need) --two-pass';
        }
    }

    method filterQuotes ($on is copy)
    {
        if $on
        {
            $on ~~ s:g/^\"(.*)\"$/$0/;
        }
        return $on;
    }

    #| Rips a single title using the settings provided
    method ripSingleTitle(Int :$title!, :$filename!, :%metadata!, :$preset = 'Normal', Bool :$no-dvdnav is copy = False) returns Hash
    {
        # First verify that no unsupported features have been requested
        self.unsupportedFeatureCheck();

        my $internalTitle = %metadata<makemkvInternalTitle>;
        if $internalTitle
        {
            self.printd: 'Using internal title '~$internalTitle~' to rip real title '~$title;
        }
        else
        {
            $internalTitle = $title;
        }

        my @command = ('makemkvcon','--noscan','--message=-stderr','--progress=-stdout','mkv','dev:'~$.device,$internalTitle,'./');
        if self.runForgeroundProcess(@command) == False
        {
            return {
                success => False
            };
        }
        # makemkvcon doesn't let us specify the filename, so we rename it manually
        # FIXME: If this file already exists, this will break badly
        ('title'~sprintf("%#02d",$title)~'.mkv').IO.rename($filename);
        return {
            success => True
        };
    }

    #| Performs a scan with makemkvcon info
    method scan () returns Hash
    {
        my $null = '/dev/null'.IO.open;
        my @cmd = ('makemkvcon','info','dev:'~$.device,'--robot');
        self.printd: "Running: "~@cmd.join(' ');
        my $in = run @cmd, :out, :err($null);

        # Keeping track of the previously seen message type, so that we can
        # reset sInfoState whenever the message type changes, and thus avoid
        # adding subtitles/audio tracks to the wrong title
        my $prev = 'NULL';
        # The results of the scan
        my %titles = (
            titleOrder => [],
            titles => {}
        );
        # The title that is currently being processed
        my $currTitle = -1;
        # The current type from SINFO
        my $sInfoState = 'NULL';
        # The results from a length message
        my $delayedLength;
        # Guessed ID for audio/sub language. makemkvcon won't use this, but in a
        # hybrid makemkvcon/HandBrakeCLI backend it can be used to try to rip
        # the correct language/subtitle.
        my $guessedTrackID;
        # Used to keep track of roundtrips through the loop where no data was parsed
        # so that we can time out if it takes too long (defined as 20 seconds of inactivity).
        my $noReplyNo = 0;
        # Used to store "playlist to title" maps for bluray
        my %plToTitle;
        while $in.exitcode == -1 || ($currTitle == -1 && $noReplyNo < 200)
        {
            $noReplyNo++;
            if ($noReplyNo % 10) == 0
            {
                self.printd: "No data for $noReplyNo loops. Waiting one second.";
                sleep 1;
            }
            for $in.out.lines -> $line
            {
                $noReplyNo = 0;
                # Retrieve the entry type (which is the first part of a line)
                my ($type,$opts) = ($line.split(':').first,$line);
                # Remove the type to get an opts line
                $opts ~~ s/^<[^:]>+://;
                # Parse out the various components of the current line
                my ($code,$flags,$count,$message,$data) = $opts.split(',');
                # MSG is a generic message. We use it to parse out 'File
                # 00000.mpls was added as title #0' messages.
                if $type eq 'MSG'
                {
                    if $code eq 'MSG:3307'
                    {
                        my @entries = $opts.split(',');
                        my $pl = self.filterQuotes(@entries[5]);
                        my $title = self.filterQuotes(@entries[6]);
                        self.printd: 'Identified '~$pl~' as internal makemkv title '~$title;
                        %plToTitle{$pl} = $title;
                    }
                    next;
                }
                # If the previous line type doesn't match the current type,
                # and the title is -1 (ie. no title yet), reset sInfoState.
                if $prev ne $type && $currTitle != -1
                {
                    $sInfoState = 'NULL';
                }
                # Store the previous type
                $prev = $type;
                # Filter away quotes from message and data, if we have them
                $message = self.filterQuotes($message);
                $data = self.filterQuotes($data);
                # TINFO provides basic information about a title. We use it to
                # fetch the title number and then length of said title
                if $type eq 'TINFO'
                {
                    # Flag 24 (DVD) or 16 (BD) indicates that the line is
                    # identifying the title number
                    if ($flags == 24 || $flags == 16)
                    {
                        $message = self.filterQuotes($message);
                        $currTitle = $message;
                        $currTitle ~~ s:g/:s\D+//;
                        $currTitle = $currTitle.Int;
                        self.printd: 'Identified title '~$currTitle;
                        %titles<titles>{$currTitle} = {
                            duration => {},
                            makemkvInternalTitle => %plToTitle{$message}
                        };
                        %titles<titleOrder>.push($currTitle);
                        if $delayedLength
                        {
                            %titles<titles>{$currTitle}<duration> = self.parseTimestamp($delayedLength);
                        }
                        else
                        {
                            $delayedLength = Nil;
                        }
                    }
                    # Flag 9 indicates that the line is providing the length of
                    # the title
                    elsif $flags == 9
                    {
                        $delayedLength = $message;
                    }
                }
                # SINFO provides additional info for the title, we use it to
                # retrieve the audio and subtitle languages for the most
                # recently seen title.
                elsif $type eq 'SINFO'
                {
                    # The presence of a 6202 message indicates that it's an
                    # audio message
                    if $message eq '6202' && $sInfoState ne 'audio'
                    {
                        $sInfoState = 'audio';
                        $guessedTrackID = 0;
                    }
                    # The presence of a 6203 message indicates that it's a
                    # subtitle message
                    elsif $message eq '6203' && $sInfoState ne 'subtitles'
                    {
                        $sInfoState = 'subtitles';
                        $guessedTrackID = 0;
                    }
                    # count=3 indicates that this single line contains the ISO
                    # language identifier for this $sInfoState entry
                    if $count eq '3'
                    {
                        if $sInfoState eq 'NULL'
                        {
                            self.printd: 'Got SINFO data, but sInfoState is null. Discarding it.';
                        }
                        else
                        {
                            $guessedTrackID++;
                            if ! %titles<titles>{$currTitle}{$sInfoState}
                            {
                                %titles<titles>{$currTitle}{$sInfoState} = {};
                            }
                            %titles<titles>{$currTitle}{$sInfoState}{$data} = {
                                name => $data,
                                id   => $guessedTrackID,
                            };
                        }
                    }
                }
            }
        }
        self.printd('Finished scanning');
        return %titles;
    }
}

#| Backend: Hybrid between HandBrakeCLI and makemkv, using HandBrakeCLI for ripping, makemkv for scanning
class backend_hybrid_mkvscan is backend_HDB
{
    has Str @.dependencies = ('HandBrakeCLI','mp4info','makemkvcon');

    method scan ()
    {
        state $mkvbackend;
        if !$mkvbackend
        {
            $mkvbackend = self.instantiateBackend(backend_mmkv);
        }
        self.printd: 'Passing scanning on to backend_mmkv';
        return $mkvbackend.scan();
    }
}

#| Backend: Hybrid between HandBrakeCLI and lsdvd, using HandBrakeCLI for ripping, lsdvd for scanning
class backend_hybrid_lsdvdscan is backend_HDB
{
    has Str @.dependencies = ('HandBrakeCLI','mp4info','lsdvd');

    method scan ()
    {
        state $lsdvbackend;
        if !$lsdvbackend
        {
            $lsdvbackend = self.instantiateBackend(backend_scan_lsdvd);
        }
        return $lsdvbackend.scan();
    }
}

#| Class that handles all of the actual ripping etc.
class LazyBrake is lazyBase
{
    has Str  $.subtitle;
    has Str  $.audiolang;
    has Str  $.name;
    has Bool $.scan;
    has Bool $.permitEject = True;
    has Bool $.dry-run = False;
    has Str  @.errorDiscs is rw;
    has Int  $.discsAttempted is rw = 0;
    has Int  $.ripSuccess is rw = 0;
    has Str  $.useBackend = 'DEFAULT';

    method getBackendByName (Str $name)
    {
        if $name eq 'makemkv'
        {
            return backend_mmkv;
        }
        elsif $name eq 'handbrake'
        {
            return backend_HDB;
        }
        elsif $name eq 'hybrid-mkv-hdb'
        {
            return backend_hybrid_mkvscan;
        }
        elsif $name eq 'hybrid-lsdvd-hdb'
        {
            return backend_hybrid_lsdvdscan;
        }
        return Nil;
    }

    #| Returns our current backend object
    method backend ()
    {
        state $backend;
        if !$backend
        {
            my %attempted;
            my $brokenBackend;
            my @backends = ( { name => 'handbrake', obj => backend_HDB}, { name => 'makemkv', obj => backend_mmkv });
            my $requested;
            if $.useBackend && $.useBackend ne 'DEFAULT'
            {
                @backends = ();
                for $.useBackend.split(',') -> $request
                {
                    $requested = self.getBackendByName($request);
                    if defined $requested
                    {
                        self.errOut("Unknown --backend: $request");
                    }
                    self.printd: 'Resolved backend "'~$request~'" to class '~$requested.^name;
                    @backends.push({ name => $request, obj => $requested });
                }
            }
            else
            {
                my %discMeta = self.getDiscMetadata();
                if %discMeta<BD>
                {
                    self.printv: 'Disc is BD, only allowing the makemkv backend';
                    @backends = ( { name => 'makemkv', obj => backend_mmkv } );
                }
            }
            for @backends -> %tryBackend
            {
                my $backendClass = %tryBackend<obj>;
                if !%attempted{$backendClass.^name}
                {
                    %attempted{$backendClass.^name} = True;
                    $backend = self.instantiateBackend($backendClass);
                    if $backend.usable()
                    {
                        self.printd: 'Instantiated backend: '~$backend.^name;
                        return $backend;
                    }
                    else
                    {
                        self.printd: 'Backend '~$backend.^name~' reports that it is not usable';
                        $brokenBackend = { objInstance => $backend, name => %tryBackend<name> };
                        $backend = Nil;
                    }
                }
            }
            if !$backend
            {
                if $.useBackend
                {
                    self.errOut(
                        'Unable to use the backend "'~$brokenBackend<name>~'"'~"\n"~
                        'The following dependencies must be met: '~$brokenBackend<objInstance>.dependencies().join(', ')
                    );
                }
                else
                {
                    self.errOut('Was unable to find any usable backend. Install HandBrakeCLI to use lazybrake.');
                }
            }
        }
        return $backend;
    }

    #| Thin wrapper around the backend scan()
    method scan ()
    {
        return self.backend().scan();
    }

    #| Eject a disc
    method eject (Bool :$wait = False)
    {
        if $.permitEject
        {
            if $.dry-run && !$.looping
            {
                say "Would have ejected the disc if not for --dry-run"
            }
            else
            {
                self.printd: "Running: eject "~$.device;
                run 'eject', $.device;
            }
        }
    }

    #| Outputs our summary
    method summary ()
    {
        say "\r   \r\nSummary:";
        say "Ripped "~$.ripSuccess~" of "~$.discsAttempted~" discs";
        if @.errorDiscs
        {
            say "The following discs failed: "~@.errorDiscs.join(', ');
        }
    }

    #| Handle ripping of a single disc
    method handleDisc (:$name = $.name, *@titles)
    {
        print "Scanning disc...";
        $.discsAttempted++;
        my %metadata = self.getDiscMetadata();
        print ".";
        my %scanData = self.scan();
        print "done\n";
        if %scanData<titleOrder>.elems == 0
        {
            self.errOut: "Found no titles on this disc, it does not appear to be a DVD video disc.", canRecover => True;
        }
        if @titles.elems == 0
        {
            @titles = self.backend().resolveTitles(%scanData);
        }
        if @titles.elems == 0
        {
            self.errOut: "Found no titles on this disc. Try changing --min-duration and --max-duration", canRecover => True;
        }
        if (self.ripTitles(
            :$name,
            :%scanData,
            :@titles,
            volume_id => %metadata<LABEL>,
            volume_uuid => %metadata<UUID>,
        ))
        {
            $.ripSuccess++;
        }
        self.eject();
    }

    #| Outputs data from a HandBrakeCLI --scan (as returned by performHDBScan) and exits
    method outputScanData (:$min-duration)
    {
        print "Scanning disc...";
        my %scanData = self.scan();
        my %discMeta = self.getDiscMetadata();
        print "done\n";
        say "Disc reports its name as %discMeta<LABEL>";
        for @(%scanData<titleOrder>) -> $title
        {
            print "Title $title";
            my $len = %scanData<titles>.{$title}.<duration>.<seconds>;
            $len   += %scanData<titles>.{$title}.<duration>.<minutes> *60;
            $len   += (%scanData<titles>.{$title}.<duration>.<hours> *60)*60;
            print sprintf(" (%-5d seconds [%02d:%02d:%02d])", $len, %scanData<titles>.{$title}.<duration>.<hours>, %scanData<titles>.{$title}.<duration>.<minutes>, %scanData<titles>.{$title}.<duration>.<seconds>);
            if %scanData<titles>.{$title}.<subtitles>
            {
                print " (subtitles: "~%scanData<titles>.{$title}.<subtitles>.keys.join(', ')~")";
            }
            if %scanData<titles>.{$title}.<audio>
            {
                print " (audio: "~%scanData<titles>.{$title}.<audio>.keys.join(', ')~")";
            }
            if %scanData<titles>.{$title}.<mainTitle>
            {
                print " [MAIN TITLE]";
            }
            print "\n";
        }
        exit 0;
    }

    #| Construct a file name
    method buildFileName (Int :$title!, :$volume_id!, :$volume_uuid!, Str :$extension is copy, Str :$name!) returns Str
    {
        if !$extension
        {
            $extension = self.backend().extension;
        }
        my $finalName;
        if $name.defined && $name.chars > 0
        {
            $finalName = $name~'_';
        }
        my $padTitle = sprintf "%02d",$title;
        $finalName ~= $padTitle~'_'~$volume_id~'_'~$volume_uuid~'.'~$extension;
        return $finalName;
    }

    #| Rip an array of titles, validating their size etc. once done and
    #| re-ripping if needed
    method ripTitles(:$name!, :$volume_id, :$volume_uuid, :$preset = 'Normal', :%scanData!, :@titles!) returns Bool
    {
        say "Queued "~@titles.elems~" titles for ripping: @titles.join(', ')";
        my $jobNumber = 1;
        my @ripped;
        my $largestRipped = 0;
        for @titles -> $title
        {
            my $filename = self.ripTitle(
                :$name,
                :$volume_id,
                :$volume_uuid,
                :$title,
                metadata => %(%scanData<titles>.{$title}),
                jobTotal => @titles.elems,
                jobNo    => $jobNumber,
            );

            if $filename.IO.e
            {
                my $bytesPerSecond = $filename.IO.s / %scanData<titles>.{$title}.<duration>.<totalInSeconds>;

                @ripped.push({
                    jobNo          => $jobNumber,
                    filename       => $filename,
                    title          => $title,
                    metadata       => %(%scanData<titles>.{$title}),
                    bytesPerSecond => $bytesPerSecond,
                    duration       => %scanData<titles>.{$title}.<duration>.<totalInSeconds>,
                });
                if $bytesPerSecond > $largestRipped
                {
                    $largestRipped = $bytesPerSecond;
                }
            }
            $jobNumber++;
        }
        if @titles.elems > 1
        {
            @titles = ();
            $jobNumber = 1;
            print "Validating files...";
            for @ripped -> %processed
            {
                if ! self.backend().validateFile(
                    file          => %processed<filename>,
                    largestRipped => $largestRipped,
                    duration      => %processed<duration>
                )
                {
                    self.printv: %processed<filename>~" failed validation, queuing for re-rip";
                    @titles.push(%processed);
                }
            }
            say "done";
            if @titles
            {
                say "Queued "~@titles.elems~" titles for re-ripping "~( $.try-dvdnav ?? '(without dvdnav) ' !! '')~"due to incomplete rips"~@titles.map({ .<title> }).join(', ');
                for @titles -> %entry
                {
                    my $tmpStorageName = %entry<filename>~'-lazybrake.validation.backup~';
                    %entry<filename>.IO.rename($tmpStorageName);
                    my $title = %entry<title>;
                    my $filename = self.ripTitle(
                        :$name,
                        :$volume_id,
                        :$volume_uuid,
                        :$title,
                        metadata  => %(%scanData<titles>.{$title}),
                        jobTotal  => @titles.elems,
                        jobNo     => $jobNumber,
                        no-dvdnav => True,
                    );

                    if ! self.backend().validateFile(
                        file          => $filename,
                        largestRipped => $largestRipped,
                        duration      => %scanData<titles>.{$title}.<duration>.<totalInSeconds>
                    )
                    {
                        say "$filename: failed validation, even after re-rip.";
                        say "It might not have been ripped properly, you should verify the file manually.";
                        say "(keeping the most complete rip, deleting the others)";
                        if $filename.IO.s < $tmpStorageName.IO.s
                        {
                            $filename.IO.unlink;
                            $tmpStorageName.IO.rename($filename);
                        }
                        else
                        {
                            $tmpStorageName.IO.unlink;
                        }
                    }
                    $jobNumber++;
                }
            }
        }
        return True;
    }

    #| Rip a single title
    method ripTitle(Int :$title!, :$name!, :$volume_id!, :$volume_uuid!, :%metadata!, :$jobNo!, :$jobTotal!, :$preset = 'Normal', Bool :$no-dvdnav) returns Str
    {
        my $i = 0;
        loop
        {
            if $i == 0
            {
                sleep(2);
            }
            $i++;

            my $filename = self.buildFileName(:$title, :$name, :$volume_id, :$volume_uuid);
            if $filename.IO.e
            {
                print "$filename: already exists (title $title)";
                if self.backend().validateFile(file => $filename, duration => %metadata<duration>.<totalInSeconds>)
                {
                    say ", skipping this title";
                    return $filename;
                }
                say ", but it failed validation. Re-ripping.";
                $filename.IO.unlink;
            }
            if !$.dry-run
            {
                if $jobTotal > 1
                {
                    print '['~(sprintf "%02d",$jobNo)~'/'~(sprintf "%02d",$jobTotal)~'] ';
                }
                say "Ripping title $title to $filename:";
                my %response = self.backend().ripSingleTitle(
                    :$title,
                    :$filename,
                    :%metadata,
                    :$preset,
                    :$no-dvdnav,
                );
                if ! %response<success>
                {
                    if $i >= 5
                    {
                        say "HandBrakeCLI returned an error. Aborting";
                        say "This could be due to a bug in HandBrakeCLI or a bad disc.";
                        say "If you tried to rip subtitles you may wish to try without them.";
                        say "If you want more details, run lazybrake with --full-debug";
                    }
                    else
                    {
                        say "HandBrakeCLI returned an error, will retry [attempt $i/5].";
                    }
                    next;
                }
                my $tmpStorageName = %response<tmpName>;
                if !$filename.IO.e
                {
                    if $i >= 5
                    {
                        say "Fatal error during ripping. Target file does not exist. Aborting.";
                        exit 13;
                    }
                    say "An error occurred during ripping, will retry [attempt $i/5].";
                    next;
                }
                if !self.backend().validateFile(file => $filename, duration => %metadata<duration>.<totalInSeconds>) && $tmpStorageName && $tmpStorageName.IO.s > $filename.IO.s
                {
                    $filename.IO.unlink;
                    $tmpStorageName.IO.rename($filename);
                }
                elsif $tmpStorageName
                {
                    $tmpStorageName.IO.unlink;
                }
            }
            else
            {
                say "Would have ripped title $title to $filename";
            }
            return $filename;
        }
    }

    #| Check if a disc is present in the drive
    method isDiscPresent() returns Bool
    {
        my %info = self.getDiscMetadata();
        return ( %info<MEDIA> || %info<DVD> || %info<BD> );
    }

    #| Do a rip loop
    method ripLoop (Int :$disc-no! is rw, *@titles)
    {
        $.looping = True;

        # Handle SIGINT gracefully, as it is our primary exit method when looping
        signal(SIGINT).tap({
            self.summary();
            exit 0;
        });
        # Output a waiting message if there's no disk in the drive when we enter the loop
        if !self.isDiscPresent
        {
            say "Waiting for disc to be inserted...";
        }
        # We loop indefinetely
        while True
        {
            # Sleep for five second periods until we have a disc in the drive
            while ! self.isDiscPresent
            {
                sleep(5);
            }
            # Generate a disc specific name
            my $discName = '';
            if $.name.defined && $.name.chars > 0
            {
                $discName = $.name~'-';
            }
            $discName ~= 'D'~sprintf("%02d",$disc-no);

            say "Processing disc $disc-no";
            # Run the disc generation
            try
            {
                CATCH
                {
                    when recoverableError
                    {
                        say "Skipping this disc.";
                        my %meta;
                        my $vol;
                        try
                        {
                            %meta = self.getDiscMetadata();
                            $vol = %meta<LABEL>;
                        }
                        if !$vol
                        {
                            $vol = 'UnknownDisc'+$.discsAttempted;
                        }
                        @.errorDiscs.push($vol);
                        self.eject();
                        sleep 2;
                    }
                }
                self.handleDisc(
                    name => $discName,
                    @titles
                );
            }

            say "Finished ripping disc $disc-no\n";

            $disc-no++;
            # Give the drive two seconds to finish ejecting before we poll it
            sleep 2;
        }
    }
}

#|{ Print formatted --help output.
Usage: printHelp('-shortoption', '--longoption', 'description');
Description will be reformatted to fit within a normal terminal }
sub printHelp (Str $short is copy, Str $long is copy, Str $desc)
{
    # The generated description that will be printed in the end
    my $GeneratedDesc;
    # The current line of the description
    my $currdesc = '';
    # The maximum length any line can be
    my Int $maxlen = 80;
    # The length the options take up
    my Int $optionlen = 23;
    # Check if the short/long are LONGER than optionlen, if so, we need
    # to do some additional magic to take up only $maxlen.
    # The +1 here is because we always add a space between them, no matter what
    if (($short.chars + $long.chars) + 1) > $optionlen
    {
        $optionlen = $short.chars + $long.chars + 1;
    }
    # Split the description into lines
    for $desc.split(' ') -> $part
    {
        if $GeneratedDesc.defined
        {
            if ($currdesc.chars + $part.chars + 1 + 24) > $maxlen
            {
                $GeneratedDesc ~= "\n";
                $currdesc = '';
            }
            else
            {
                $currdesc ~= ' ';
                $GeneratedDesc ~= ' ';
            }
        }
        $currdesc ~= $part;
        $GeneratedDesc ~= $part;
    }
    # Print it all
    for $GeneratedDesc.split("\n") -> $description
    {
        say sprintf "%-4s %-22s %s", $short,$long,$description;
        $short = '';$long = '';
    }
    # Something went wrong
    die('Option mismatch') if !$GeneratedDesc;
    # Succeed
    return True;
}

#| Output version information
sub version ()
{
    say 'lazybrake version '~$version;
    exit;
}

#| Command-line parsing
sub MAIN (
    Str :$device  is copy,
    Int :$max-duration = 3600,
    Int :$min-duration = 900,
    Int :$disc-no is copy = 1,
    Str :$name         = '',
    Bool :$version     = False,
    Bool :$scan        = False,
    Bool :$tv     is copy = False,
    Bool :$movie  is copy = False,
    Bool :$dry-run     = False,
    Bool :$loop        = False,
    Bool :$verbose     = False,
    Bool :$debug       = False,
    Bool :$full-debug  = False,
    Bool :$no-eject    = False,
    Bool :$no-dvdnav   = False,
    Bool :$two-pass    = False,
    Str  :$pass-opts,
    Str :$subtitle,
    Str :$audiolang,
    Str :$backend,
    *@title)
{
    if $version
    {
        version();
    }
    my Int $verbosity = 0;
    my Bool $permitEject = !$no-eject;
    # Handle --device being missing
    if ! $device.defined
    {
        if '/dev/sr0'.IO.e
        {
            $device = '/dev/sr0';
        }
        elsif '/dev/cdrom'.IO.e
        {
            $device = '/dev/cdrom';
        }
        else
        {
            LazyBrake.new.errOut: "Failed to detect a DVD-rom, provide a --device on the command-line";
        }
    }
    # Handle --movie and --tv
    if ($tv == True && $movie == True)
    {
        LazyBrake.new.errOut: "--movie and --tv conflicts";
    }
    if ($tv == True)
    {
        $movie = False;
    }
    elsif ($movie)
    {
        $tv = False;
    }
    else
    {
        $tv = True;
    }
    # Handle --debug and --verbose
    if $full-debug
    {
        $verbosity = 199;
    }
    elsif $debug
    {
        $verbosity = 99;
    }
    elsif $verbose
    {
        $verbosity = 1;
    }
    my $lazybrake = LazyBrake.new(
        :$device,
        :$min-duration,
        :$name,
        :$tv,
        :$subtitle,
        :$audiolang,
        :$max-duration,
        :$dry-run,
        :$permitEject,
        :$disc-no,
        :$scan,
        :$movie,
        :$verbosity,
        :$two-pass,
        :$pass-opts,
        useBackend => $backend,
        try-dvdnav => !$no-dvdnav,
    );
    # Output scan info if --scan was supplied
    if $scan
    {
        if ! $lazybrake.isDiscPresent()
        {
            say "Found no disc in drive $device";
            exit 0;
        }
        $lazybrake.outputScanData(:$device,:$min-duration);
    }
    # Enter a rip loop if --loop was supplied
    if $loop
    {
        $lazybrake.ripLoop(
            :$disc-no,
            device => $device,
            @title
        );
    }
    else
    {
        if ! $lazybrake.isDiscPresent()
        {
            $lazybrake.errOut: "Found no disc in drive $device";
        }
        $lazybrake.handleDisc(
            @title
        );
    }
}

sub USAGE ()
{
    print "\n";
    print 'Usage: '~$*PROGRAM-NAME.IO.basename~' [OPTIONS] [<title> ...]'~"\n";
    print "\n";
    print "Options:\n";
    printHelp('' , '--help'             , 'View this help screen.');
    printHelp('' , '--device=Str'       , 'Override the path to the DVD-Rom device.');
    printHelp('' , '--max-duration=Int' , 'Set the max duration of a track to rip in seconds (when in TV mode), default is 3600.');
    printHelp('' , '--min-duration=Int' , 'Set the minimum duration of a track to rip in seconds (when in TV mode), default is 900.');
    printHelp('' , '--two-pass'         , 'Enable two-pass encoding (default: disabled)');
    printHelp('' , '--name=Str'         , 'Set the name prefix for files.');
    printHelp('' , '--pass-opts=Str'    , 'Pass an option directly to HandBrakeCLI. See the manpage for details.');
    printHelp('' , '--tv'               , 'Enable TV mode, rips several titles from a disc (ie. episodes) - the default.');
    printHelp('' , '--movie'            , 'Enable movie mode, rips only the main title from a disc (ie. the movie itself).');
    printHelp('' , '--dry-run'          , 'Don\'t actually rip anything, just output the messages.');
    printHelp('' , '--loop'             , 'Loop, rip a disc, eject it, and then rip another disc once it is inserted. Useful when ripping multi-disc TV series or multiple movies.');
    printHelp('' , '--subtitle=Str'     , 'Set a subtitle to rip. Accepts a comma-delimited list of subtitles (default is to not rip any subtitles).');
    printHelp('' , '--audiolang=Str'    , 'Set the audio language. Accepts a comma-delimited list of languages (if omitted, the default language track will be ripped).');
    printHelp('' , '--disc-no=Int'      , 'Set the disc number for loop. Can be used to resume ripping on a disc other than 1.');
    printHelp('' , '--no-eject'         , 'Don\'t eject the disc once finished ripping. Not usable with --loop.');
    printHelp('' , '--verbose'          , 'Increase verbosity.');
    printHelp('' , '--debug'            , 'Enable debug output.');
}
